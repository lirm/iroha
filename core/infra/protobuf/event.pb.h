// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: event.proto

#ifndef PROTOBUF_event_2eproto__INCLUDED
#define PROTOBUF_event_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Event {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_event_2eproto();
void protobuf_AssignDesc_event_2eproto();
void protobuf_ShutdownFile_event_2eproto();

class Account;
class Asset;
class ConsensusEvent;
class Domain;
class EventSignature;
class StatusResponse;
class Transaction;
class TxSignatures;

// ===================================================================

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  void Swap(Asset* other);

  // implements Message ----------------------------------------------

  inline Asset* New() const { return New(NULL); }

  Asset* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // optional uint64 precision = 4;
  void clear_precision();
  static const int kPrecisionFieldNumber = 4;
  ::google::protobuf::uint64 precision() const;
  void set_precision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Event.Asset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 value_;
  ::google::protobuf::uint64 precision_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Asset* default_instance_;
};
// -------------------------------------------------------------------

class Domain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Domain) */ {
 public:
  Domain();
  virtual ~Domain();

  Domain(const Domain& from);

  inline Domain& operator=(const Domain& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Domain& default_instance();

  void Swap(Domain* other);

  // implements Message ----------------------------------------------

  inline Domain* New() const { return New(NULL); }

  Domain* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Domain& from);
  void MergeFrom(const Domain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Domain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ownerPublicKey = 1;
  void clear_ownerpublickey();
  static const int kOwnerPublicKeyFieldNumber = 1;
  const ::std::string& ownerpublickey() const;
  void set_ownerpublickey(const ::std::string& value);
  void set_ownerpublickey(const char* value);
  void set_ownerpublickey(const char* value, size_t size);
  ::std::string* mutable_ownerpublickey();
  ::std::string* release_ownerpublickey();
  void set_allocated_ownerpublickey(::std::string* ownerpublickey);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Event.Domain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ownerpublickey_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Domain* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  inline Account* New() const { return New(NULL); }

  Account* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .Event.Asset assets = 3;
  int assets_size() const;
  void clear_assets();
  static const int kAssetsFieldNumber = 3;
  const ::Event::Asset& assets(int index) const;
  ::Event::Asset* mutable_assets(int index);
  ::Event::Asset* add_assets();
  ::google::protobuf::RepeatedPtrField< ::Event::Asset >*
      mutable_assets();
  const ::google::protobuf::RepeatedPtrField< ::Event::Asset >&
      assets() const;

  // @@protoc_insertion_point(class_scope:Event.Account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::Event::Asset > assets_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class TxSignatures : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.TxSignatures) */ {
 public:
  TxSignatures();
  virtual ~TxSignatures();

  TxSignatures(const TxSignatures& from);

  inline TxSignatures& operator=(const TxSignatures& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSignatures& default_instance();

  void Swap(TxSignatures* other);

  // implements Message ----------------------------------------------

  inline TxSignatures* New() const { return New(NULL); }

  TxSignatures* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxSignatures& from);
  void MergeFrom(const TxSignatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TxSignatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:Event.TxSignatures)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static TxSignatures* default_instance_;
};
// -------------------------------------------------------------------

class EventSignature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.EventSignature) */ {
 public:
  EventSignature();
  virtual ~EventSignature();

  EventSignature(const EventSignature& from);

  inline EventSignature& operator=(const EventSignature& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventSignature& default_instance();

  void Swap(EventSignature* other);

  // implements Message ----------------------------------------------

  inline EventSignature* New() const { return New(NULL); }

  EventSignature* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventSignature& from);
  void MergeFrom(const EventSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string publicKey = 1;
  void clear_publickey();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& publickey() const;
  void set_publickey(const ::std::string& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  ::std::string* mutable_publickey();
  ::std::string* release_publickey();
  void set_allocated_publickey(::std::string* publickey);

  // optional string signature = 2;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:Event.EventSignature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr publickey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static EventSignature* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  inline Transaction* New() const { return New(NULL); }

  Transaction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Event.TxSignatures txSignatures = 1;
  int txsignatures_size() const;
  void clear_txsignatures();
  static const int kTxSignaturesFieldNumber = 1;
  const ::Event::TxSignatures& txsignatures(int index) const;
  ::Event::TxSignatures* mutable_txsignatures(int index);
  ::Event::TxSignatures* add_txsignatures();
  ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >*
      mutable_txsignatures();
  const ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >&
      txsignatures() const;

  // optional string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string senderPubkey = 3;
  void clear_senderpubkey();
  static const int kSenderPubkeyFieldNumber = 3;
  const ::std::string& senderpubkey() const;
  void set_senderpubkey(const ::std::string& value);
  void set_senderpubkey(const char* value);
  void set_senderpubkey(const char* value, size_t size);
  ::std::string* mutable_senderpubkey();
  ::std::string* release_senderpubkey();
  void set_allocated_senderpubkey(::std::string* senderpubkey);

  // optional string hash = 4;
  void clear_hash();
  static const int kHashFieldNumber = 4;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional uint64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional .Event.Asset asset = 6;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 6;
  const ::Event::Asset& asset() const;
  ::Event::Asset* mutable_asset();
  ::Event::Asset* release_asset();
  void set_allocated_asset(::Event::Asset* asset);

  // optional .Event.Domain domain = 7;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 7;
  const ::Event::Domain& domain() const;
  ::Event::Domain* mutable_domain();
  ::Event::Domain* release_domain();
  void set_allocated_domain(::Event::Domain* domain);

  // optional .Event.Account account = 8;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 8;
  const ::Event::Account& account() const;
  ::Event::Account* mutable_account();
  ::Event::Account* release_account();
  void set_allocated_account(::Event::Account* account);

  // optional string receivePubkey = 9;
  void clear_receivepubkey();
  static const int kReceivePubkeyFieldNumber = 9;
  const ::std::string& receivepubkey() const;
  void set_receivepubkey(const ::std::string& value);
  void set_receivepubkey(const char* value);
  void set_receivepubkey(const char* value, size_t size);
  ::std::string* mutable_receivepubkey();
  ::std::string* release_receivepubkey();
  void set_allocated_receivepubkey(::std::string* receivepubkey);

  // @@protoc_insertion_point(class_scope:Event.Transaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures > txsignatures_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr senderpubkey_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint64 timestamp_;
  ::Event::Asset* asset_;
  ::Event::Domain* domain_;
  ::Event::Account* account_;
  ::google::protobuf::internal::ArenaStringPtr receivepubkey_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class ConsensusEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.ConsensusEvent) */ {
 public:
  ConsensusEvent();
  virtual ~ConsensusEvent();

  ConsensusEvent(const ConsensusEvent& from);

  inline ConsensusEvent& operator=(const ConsensusEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusEvent& default_instance();

  void Swap(ConsensusEvent* other);

  // implements Message ----------------------------------------------

  inline ConsensusEvent* New() const { return New(NULL); }

  ConsensusEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConsensusEvent& from);
  void MergeFrom(const ConsensusEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConsensusEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Event.EventSignature eventSignatures = 1;
  int eventsignatures_size() const;
  void clear_eventsignatures();
  static const int kEventSignaturesFieldNumber = 1;
  const ::Event::EventSignature& eventsignatures(int index) const;
  ::Event::EventSignature* mutable_eventsignatures(int index);
  ::Event::EventSignature* add_eventsignatures();
  ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >*
      mutable_eventsignatures();
  const ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >&
      eventsignatures() const;

  // optional .Event.Transaction transaction = 2;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 2;
  const ::Event::Transaction& transaction() const;
  ::Event::Transaction* mutable_transaction();
  ::Event::Transaction* release_transaction();
  void set_allocated_transaction(::Event::Transaction* transaction);

  // optional uint64 order = 3;
  void clear_order();
  static const int kOrderFieldNumber = 3;
  ::google::protobuf::uint64 order() const;
  void set_order(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Event.ConsensusEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Event::EventSignature > eventsignatures_;
  ::Event::Transaction* transaction_;
  ::google::protobuf::uint64 order_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static ConsensusEvent* default_instance_;
};
// -------------------------------------------------------------------

class StatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Event.StatusResponse) */ {
 public:
  StatusResponse();
  virtual ~StatusResponse();

  StatusResponse(const StatusResponse& from);

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusResponse& default_instance();

  void Swap(StatusResponse* other);

  // implements Message ----------------------------------------------

  inline StatusResponse* New() const { return New(NULL); }

  StatusResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusResponse& from);
  void MergeFrom(const StatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Event.StatusResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_event_2eproto();
  friend void protobuf_AssignDesc_event_2eproto();
  friend void protobuf_ShutdownFile_event_2eproto();

  void InitAsDefaultInstance();
  static StatusResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Asset

// optional string domain = 1;
inline void Asset::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::domain() const {
  // @@protoc_insertion_point(field_get:Event.Asset.domain)
  return domain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Asset.domain)
}
inline void Asset::set_domain(const char* value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Asset.domain)
}
inline void Asset::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Asset.domain)
}
inline ::std::string* Asset::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:Event.Asset.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_domain() {
  // @@protoc_insertion_point(field_release:Event.Asset.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:Event.Asset.domain)
}

// optional string name = 2;
inline void Asset::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Asset::name() const {
  // @@protoc_insertion_point(field_get:Event.Asset.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Asset.name)
}
inline void Asset::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Asset.name)
}
inline void Asset::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Asset.name)
}
inline ::std::string* Asset::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.Asset.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Asset::release_name() {
  // @@protoc_insertion_point(field_release:Event.Asset.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Asset::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.Asset.name)
}

// optional uint64 value = 3;
inline void Asset::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Asset::value() const {
  // @@protoc_insertion_point(field_get:Event.Asset.value)
  return value_;
}
inline void Asset::set_value(::google::protobuf::uint64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Event.Asset.value)
}

// optional uint64 precision = 4;
inline void Asset::clear_precision() {
  precision_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Asset::precision() const {
  // @@protoc_insertion_point(field_get:Event.Asset.precision)
  return precision_;
}
inline void Asset::set_precision(::google::protobuf::uint64 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:Event.Asset.precision)
}

// -------------------------------------------------------------------

// Domain

// optional string ownerPublicKey = 1;
inline void Domain::clear_ownerpublickey() {
  ownerpublickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::ownerpublickey() const {
  // @@protoc_insertion_point(field_get:Event.Domain.ownerPublicKey)
  return ownerpublickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_ownerpublickey(const ::std::string& value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Domain.ownerPublicKey)
}
inline void Domain::set_ownerpublickey(const char* value, size_t size) {
  
  ownerpublickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Domain.ownerPublicKey)
}
inline ::std::string* Domain::mutable_ownerpublickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Domain.ownerPublicKey)
  return ownerpublickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_ownerpublickey() {
  // @@protoc_insertion_point(field_release:Event.Domain.ownerPublicKey)
  
  return ownerpublickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_ownerpublickey(::std::string* ownerpublickey) {
  if (ownerpublickey != NULL) {
    
  } else {
    
  }
  ownerpublickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ownerpublickey);
  // @@protoc_insertion_point(field_set_allocated:Event.Domain.ownerPublicKey)
}

// optional string name = 2;
inline void Domain::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Domain::name() const {
  // @@protoc_insertion_point(field_get:Event.Domain.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Domain.name)
}
inline void Domain::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Domain.name)
}
inline void Domain::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Domain.name)
}
inline ::std::string* Domain::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.Domain.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Domain::release_name() {
  // @@protoc_insertion_point(field_release:Event.Domain.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Domain::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.Domain.name)
}

// -------------------------------------------------------------------

// Account

// optional string publicKey = 1;
inline void Account::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::publickey() const {
  // @@protoc_insertion_point(field_get:Event.Account.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Account.publicKey)
}
inline void Account::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Account.publicKey)
}
inline void Account::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Account.publicKey)
}
inline ::std::string* Account::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Account.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_publickey() {
  // @@protoc_insertion_point(field_release:Event.Account.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Event.Account.publicKey)
}

// optional string name = 2;
inline void Account::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Account::name() const {
  // @@protoc_insertion_point(field_get:Event.Account.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Account.name)
}
inline void Account::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Account.name)
}
inline void Account::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Account.name)
}
inline ::std::string* Account::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Event.Account.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_name() {
  // @@protoc_insertion_point(field_release:Event.Account.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Event.Account.name)
}

// repeated .Event.Asset assets = 3;
inline int Account::assets_size() const {
  return assets_.size();
}
inline void Account::clear_assets() {
  assets_.Clear();
}
inline const ::Event::Asset& Account::assets(int index) const {
  // @@protoc_insertion_point(field_get:Event.Account.assets)
  return assets_.Get(index);
}
inline ::Event::Asset* Account::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:Event.Account.assets)
  return assets_.Mutable(index);
}
inline ::Event::Asset* Account::add_assets() {
  // @@protoc_insertion_point(field_add:Event.Account.assets)
  return assets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Event::Asset >*
Account::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:Event.Account.assets)
  return &assets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Event::Asset >&
Account::assets() const {
  // @@protoc_insertion_point(field_list:Event.Account.assets)
  return assets_;
}

// -------------------------------------------------------------------

// TxSignatures

// optional string publicKey = 1;
inline void TxSignatures::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::publickey() const {
  // @@protoc_insertion_point(field_get:Event.TxSignatures.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.TxSignatures.publicKey)
}
inline void TxSignatures::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.TxSignatures.publicKey)
}
inline ::std::string* TxSignatures::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.TxSignatures.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_publickey() {
  // @@protoc_insertion_point(field_release:Event.TxSignatures.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Event.TxSignatures.publicKey)
}

// optional string signature = 2;
inline void TxSignatures::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TxSignatures::signature() const {
  // @@protoc_insertion_point(field_get:Event.TxSignatures.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.TxSignatures.signature)
}
inline void TxSignatures::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.TxSignatures.signature)
}
inline ::std::string* TxSignatures::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Event.TxSignatures.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSignatures::release_signature() {
  // @@protoc_insertion_point(field_release:Event.TxSignatures.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSignatures::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Event.TxSignatures.signature)
}

// -------------------------------------------------------------------

// EventSignature

// optional string publicKey = 1;
inline void EventSignature::clear_publickey() {
  publickey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::publickey() const {
  // @@protoc_insertion_point(field_get:Event.EventSignature.publicKey)
  return publickey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_publickey(const ::std::string& value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.EventSignature.publicKey)
}
inline void EventSignature::set_publickey(const char* value, size_t size) {
  
  publickey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.EventSignature.publicKey)
}
inline ::std::string* EventSignature::mutable_publickey() {
  
  // @@protoc_insertion_point(field_mutable:Event.EventSignature.publicKey)
  return publickey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_publickey() {
  // @@protoc_insertion_point(field_release:Event.EventSignature.publicKey)
  
  return publickey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_publickey(::std::string* publickey) {
  if (publickey != NULL) {
    
  } else {
    
  }
  publickey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publickey);
  // @@protoc_insertion_point(field_set_allocated:Event.EventSignature.publicKey)
}

// optional string signature = 2;
inline void EventSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EventSignature::signature() const {
  // @@protoc_insertion_point(field_get:Event.EventSignature.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.EventSignature.signature)
}
inline void EventSignature::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.EventSignature.signature)
}
inline ::std::string* EventSignature::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:Event.EventSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventSignature::release_signature() {
  // @@protoc_insertion_point(field_release:Event.EventSignature.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventSignature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Event.EventSignature.signature)
}

// -------------------------------------------------------------------

// Transaction

// repeated .Event.TxSignatures txSignatures = 1;
inline int Transaction::txsignatures_size() const {
  return txsignatures_.size();
}
inline void Transaction::clear_txsignatures() {
  txsignatures_.Clear();
}
inline const ::Event::TxSignatures& Transaction::txsignatures(int index) const {
  // @@protoc_insertion_point(field_get:Event.Transaction.txSignatures)
  return txsignatures_.Get(index);
}
inline ::Event::TxSignatures* Transaction::mutable_txsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:Event.Transaction.txSignatures)
  return txsignatures_.Mutable(index);
}
inline ::Event::TxSignatures* Transaction::add_txsignatures() {
  // @@protoc_insertion_point(field_add:Event.Transaction.txSignatures)
  return txsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >*
Transaction::mutable_txsignatures() {
  // @@protoc_insertion_point(field_mutable_list:Event.Transaction.txSignatures)
  return &txsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Event::TxSignatures >&
Transaction::txsignatures() const {
  // @@protoc_insertion_point(field_list:Event.Transaction.txSignatures)
  return txsignatures_;
}

// optional string type = 2;
inline void Transaction::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::type() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.type)
}
inline void Transaction::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.type)
}
inline void Transaction::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.type)
}
inline ::std::string* Transaction::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_type() {
  // @@protoc_insertion_point(field_release:Event.Transaction.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.type)
}

// optional string senderPubkey = 3;
inline void Transaction::clear_senderpubkey() {
  senderpubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::senderpubkey() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.senderPubkey)
  return senderpubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_senderpubkey(const ::std::string& value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.senderPubkey)
}
inline void Transaction::set_senderpubkey(const char* value, size_t size) {
  
  senderpubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.senderPubkey)
}
inline ::std::string* Transaction::mutable_senderpubkey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.senderPubkey)
  return senderpubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_senderpubkey() {
  // @@protoc_insertion_point(field_release:Event.Transaction.senderPubkey)
  
  return senderpubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_senderpubkey(::std::string* senderpubkey) {
  if (senderpubkey != NULL) {
    
  } else {
    
  }
  senderpubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), senderpubkey);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.senderPubkey)
}

// optional string hash = 4;
inline void Transaction::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::hash() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.hash)
}
inline void Transaction::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.hash)
}
inline void Transaction::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.hash)
}
inline ::std::string* Transaction::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_hash() {
  // @@protoc_insertion_point(field_release:Event.Transaction.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.hash)
}

// optional uint64 timestamp = 5;
inline void Transaction::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Transaction::timestamp() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.timestamp)
  return timestamp_;
}
inline void Transaction::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Event.Transaction.timestamp)
}

// optional .Event.Asset asset = 6;
inline bool Transaction::has_asset() const {
  return !_is_default_instance_ && asset_ != NULL;
}
inline void Transaction::clear_asset() {
  if (GetArenaNoVirtual() == NULL && asset_ != NULL) delete asset_;
  asset_ = NULL;
}
inline const ::Event::Asset& Transaction::asset() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.asset)
  return asset_ != NULL ? *asset_ : *default_instance_->asset_;
}
inline ::Event::Asset* Transaction::mutable_asset() {
  
  if (asset_ == NULL) {
    asset_ = new ::Event::Asset;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.asset)
  return asset_;
}
inline ::Event::Asset* Transaction::release_asset() {
  // @@protoc_insertion_point(field_release:Event.Transaction.asset)
  
  ::Event::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_asset(::Event::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.asset)
}

// optional .Event.Domain domain = 7;
inline bool Transaction::has_domain() const {
  return !_is_default_instance_ && domain_ != NULL;
}
inline void Transaction::clear_domain() {
  if (GetArenaNoVirtual() == NULL && domain_ != NULL) delete domain_;
  domain_ = NULL;
}
inline const ::Event::Domain& Transaction::domain() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.domain)
  return domain_ != NULL ? *domain_ : *default_instance_->domain_;
}
inline ::Event::Domain* Transaction::mutable_domain() {
  
  if (domain_ == NULL) {
    domain_ = new ::Event::Domain;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.domain)
  return domain_;
}
inline ::Event::Domain* Transaction::release_domain() {
  // @@protoc_insertion_point(field_release:Event.Transaction.domain)
  
  ::Event::Domain* temp = domain_;
  domain_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_domain(::Event::Domain* domain) {
  delete domain_;
  domain_ = domain;
  if (domain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.domain)
}

// optional .Event.Account account = 8;
inline bool Transaction::has_account() const {
  return !_is_default_instance_ && account_ != NULL;
}
inline void Transaction::clear_account() {
  if (GetArenaNoVirtual() == NULL && account_ != NULL) delete account_;
  account_ = NULL;
}
inline const ::Event::Account& Transaction::account() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Event::Account* Transaction::mutable_account() {
  
  if (account_ == NULL) {
    account_ = new ::Event::Account;
  }
  // @@protoc_insertion_point(field_mutable:Event.Transaction.account)
  return account_;
}
inline ::Event::Account* Transaction::release_account() {
  // @@protoc_insertion_point(field_release:Event.Transaction.account)
  
  ::Event::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_account(::Event::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.account)
}

// optional string receivePubkey = 9;
inline void Transaction::clear_receivepubkey() {
  receivepubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::receivepubkey() const {
  // @@protoc_insertion_point(field_get:Event.Transaction.receivePubkey)
  return receivepubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_receivepubkey(const ::std::string& value) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.Transaction.receivePubkey)
}
inline void Transaction::set_receivepubkey(const char* value) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.Transaction.receivePubkey)
}
inline void Transaction::set_receivepubkey(const char* value, size_t size) {
  
  receivepubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.Transaction.receivePubkey)
}
inline ::std::string* Transaction::mutable_receivepubkey() {
  
  // @@protoc_insertion_point(field_mutable:Event.Transaction.receivePubkey)
  return receivepubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_receivepubkey() {
  // @@protoc_insertion_point(field_release:Event.Transaction.receivePubkey)
  
  return receivepubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_receivepubkey(::std::string* receivepubkey) {
  if (receivepubkey != NULL) {
    
  } else {
    
  }
  receivepubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receivepubkey);
  // @@protoc_insertion_point(field_set_allocated:Event.Transaction.receivePubkey)
}

// -------------------------------------------------------------------

// ConsensusEvent

// repeated .Event.EventSignature eventSignatures = 1;
inline int ConsensusEvent::eventsignatures_size() const {
  return eventsignatures_.size();
}
inline void ConsensusEvent::clear_eventsignatures() {
  eventsignatures_.Clear();
}
inline const ::Event::EventSignature& ConsensusEvent::eventsignatures(int index) const {
  // @@protoc_insertion_point(field_get:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_.Get(index);
}
inline ::Event::EventSignature* ConsensusEvent::mutable_eventsignatures(int index) {
  // @@protoc_insertion_point(field_mutable:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_.Mutable(index);
}
inline ::Event::EventSignature* ConsensusEvent::add_eventsignatures() {
  // @@protoc_insertion_point(field_add:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >*
ConsensusEvent::mutable_eventsignatures() {
  // @@protoc_insertion_point(field_mutable_list:Event.ConsensusEvent.eventSignatures)
  return &eventsignatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Event::EventSignature >&
ConsensusEvent::eventsignatures() const {
  // @@protoc_insertion_point(field_list:Event.ConsensusEvent.eventSignatures)
  return eventsignatures_;
}

// optional .Event.Transaction transaction = 2;
inline bool ConsensusEvent::has_transaction() const {
  return !_is_default_instance_ && transaction_ != NULL;
}
inline void ConsensusEvent::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) delete transaction_;
  transaction_ = NULL;
}
inline const ::Event::Transaction& ConsensusEvent::transaction() const {
  // @@protoc_insertion_point(field_get:Event.ConsensusEvent.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::Event::Transaction* ConsensusEvent::mutable_transaction() {
  
  if (transaction_ == NULL) {
    transaction_ = new ::Event::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:Event.ConsensusEvent.transaction)
  return transaction_;
}
inline ::Event::Transaction* ConsensusEvent::release_transaction() {
  // @@protoc_insertion_point(field_release:Event.ConsensusEvent.transaction)
  
  ::Event::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void ConsensusEvent::set_allocated_transaction(::Event::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Event.ConsensusEvent.transaction)
}

// optional uint64 order = 3;
inline void ConsensusEvent::clear_order() {
  order_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ConsensusEvent::order() const {
  // @@protoc_insertion_point(field_get:Event.ConsensusEvent.order)
  return order_;
}
inline void ConsensusEvent::set_order(::google::protobuf::uint64 value) {
  
  order_ = value;
  // @@protoc_insertion_point(field_set:Event.ConsensusEvent.order)
}

// -------------------------------------------------------------------

// StatusResponse

// optional string value = 1;
inline void StatusResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusResponse::value() const {
  // @@protoc_insertion_point(field_get:Event.StatusResponse.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Event.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Event.StatusResponse.value)
}
inline void StatusResponse::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Event.StatusResponse.value)
}
inline ::std::string* StatusResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:Event.StatusResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusResponse::release_value() {
  // @@protoc_insertion_point(field_release:Event.StatusResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Event.StatusResponse.value)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Event

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_event_2eproto__INCLUDED
